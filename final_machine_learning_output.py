# -*- coding: utf-8 -*-
"""Final Machine learning output.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gjLOPWI70wLCi7D4lG5WSWiHJq9x8Y
"""

#this is the implementation of machine learning for deciding the best software 
#among various features

#including the csv file
from google.colab import files

import numpy as np 
import pandas as pd
from collections import Counter
import matplotlib.pyplot as plt
import io

#askes to upload csv file
uploaded = files.upload()
data = pd.read_csv(io.StringIO(uploaded['regression.csv'].decode('utf-8')))
#print(data)

#Get data as numpy array
data_np = data.values
#print(data_np)

#slider values
#x=7
#y=3
#z=2

#populate c1 in the shape of data_np
c1=np.full(data_np.shape,1)

#subtracting the minimum requirement
data_normalized=data_np-c1
print(data_normalized)

#removing values not satisfying minimum requirement
#indices_zero=np.where(data_normalized < 0, axis=1)
#indices_withoutzero=np.indices(data_normalized > 0, axis=1)
data_normalized=data_normalized[~np.any(data_normalized < 0, axis=1)]
print("index of zero values")
#print(indices_zero)

print("index of without zero values")
#print(indices_withoutzero)

#multiplying the eligible values with slider values
#creating random slider values
x=np.random.randint(10,size=((np.size(data_normalized,1)),1))
#print(x)

np.dot(data_normalized,x)
#data_normalized[:,0]*=x
#data_normalized[:,1]*=y
#data_normalized[:,2]*=z
print("printing data normalised after multiplication")
print(data_normalized)

#squaring the values of matrix and taking square root of it
a=data_normalized
print(a)
m= np.sum((np.square(a)),axis=1)
mse=np.sqrt(m)
print(mse)

#sorting the result in descending order
print(sorted(mse,reverse=True))

#fig=plt.figure()
#ax=fig.add_subplot(111,projection='2d')

#x=prediction[:,0]
#y=prediction[:,1]
#z=data_normalized[:,2]
#x,y,z = data.T
#x1,y1,z1=c.T
#ax.scatter(x,y, c='r', marker='o')
#ax.set_xlabel('x axis')
#ax.set_xlabel('y axis')
#ax.set_xlabel('z axis')
"""
plt.figure(figsize=(10, 4))
ax = plt.subplot(234)
ax.set_aspect(1)
plt.plot(c, c='r')
plt.plot(mse, c='b')
plt.show()
"""

"""import numpy as np 
import pandas as pd
from collections import Counter
print "Hello World!\n" 
'''data_url = 'D://2ndsem//HIWIJOBS//first//regression.csv'
data = pd.read_csv(data_url, sep=';')

# inspect data
display(data.head())
print(data.shape)'''
x=5 
y=3 
z=4 
data=np.array([[4,1,5],[3,2,5],[5,3,4],[9,4,3],[1,5,2],[3,6,1],[9,7,0]])
c=[3,6,1]
mini = data.min(axis=0)
maxi = data.max(axis=0)
'''dn=Counter(data).subtract(Counter(min))'''
data_normalized = (data-mini)/(maxi-mini)
'''data_normalized[:,0]*=x
data_normalized[:,1]*=y
data_normalized[:,2]*=z
f1=Counter(data_normalized)
f2=Counter(c)
s=f1.subtract(f2)
'''
mse = np.dot((data_normalized-c).T,(data_normalized-c))
print(mse)

'''s1=np.array(s)
mse=np.dot(s1.T,s1)
m=np.array([[1,-5,4],[0,-4,4],[2,-3,3],[6,-2,2],[-2,-1,1],[0,0,0],[6,1,-1]]) 
m[:,0]*=x 
m[:,1]*=y 
m[:,2]*=z 
print(m)
print(type(m))
print(len(m))
mean=m.mean(axis=0)
print(mean)
cov=np.dot(np.transpose(m),m)/len(m)
print(cov)
m_normalized=(m-m.mean(0))/m.std(0)
print(m_normalized)
print(m_normalized.shape)'''
x, y, z = np.random.multivariate_normal(mean, cov).T
plt.plot(x, y, z)
plt.axis('equal')
plt.show()'''
"""
